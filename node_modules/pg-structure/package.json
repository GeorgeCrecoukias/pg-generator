{
  "name": "pg-structure",
  "version": "1.11.1",
  "description": "Get PostgreSQL database structure as a detailed JS Object",
  "main": "lib/pg-structure.js",
  "scripts": {
    "test": "make test"
  },
  "keywords": [
    "postgresql",
    "pg",
    "postgres",
    "database",
    "schema",
    "model",
    "schema",
    "export",
    "dump",
    "etl",
    "erd",
    "migration",
    "transform",
    "extract",
    "information_schema",
    "sequelize",
    "orm",
    "model",
    "structure",
    "auto generate",
    "meta"
  ],
  "author": {
    "name": "Özüm Eldoğan",
    "url": "http://www.fortibase.com"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ozum/pg-structure.git"
  },
  "license": "MIT",
  "devDependencies": {
    "chai": "^1.9.2",
    "ink-docstrap": "^0.5.2",
    "mocha": "^2.0.1"
  },
  "dependencies": {
    "async": "^0.9.0",
    "inflection": "^1.5.2",
    "joi": "^4.8.1",
    "lodash": "^2.4.1",
    "pg": "^4.1.1",
    "weakmap": "0.0.6",
    "winston": "^0.8.3"
  },
  "jshintConfig": {},
  "readme": "# pg-structure\n\nGet PostgreSQL database structure as a detailed JS Object.\n\n## History\n[History & Release Notes](#History)\n\n## Synopsis\n\n    var pgs     = require('pg-structure');\n    var util    = require('util');\n    pgs('127.0.0.1', 'node', 'user', 'password', { schema: ['public', 'other_schema'] }, function (err, db) {\n        if (err) { throw err; }\n        console.log(db.schema('public').name());\n\n        // Callback style\n        db.schema('public').tables(function (table) {\n            console.log(table.name());\n        });\n\n        // Array Style\n        console.log(schema('public').tables());\n\n        // Long access chain:\n        // public schema -> cart table -> contact_id columns -> foreign key constraint of contact_id\n        // -> table of the constraint -> name of the referenced table\n        console.log(db.schema('public').table('cart').column('contact_id').foreignKeyConstraint().referencesTable().name());\n    });\n\n## Abstract\n\npg-structure creates a detailed object of a PostgreSQL database. This object may be used to auto generate\ndocumentation or ORM models from database. It is much easier to work with JS object than working manually\nwith database.\n\n## Description\n\npg-structure connects to a PostgreSQL database, examines its structure and creates an JS object. The passed callback\nis executed with result object as parameter.\n\n## Special Thanks\nThis module is developed with sponsorship of Fortibase.\n\n## Features\n\n* Fully tested (Istanbul-JS coverage reports are in coverage folder)\n* Fully documented with JSDOC and HTML (HTML docs are in doc directory)\n* All PostgreSQL data types including array, JSON and HSTore\n* Support composite keys (Multiple field keys)\n* Schema support\n* Primary Keys\n* Foreign Keys\n* Unique Keys\n* Unique Indexes\n* Identifies hasMany relationships\n* Identifies possible many to many relationships (through relationships)\n* Columns can be accessed by name or by order. (Contains object and array referencing to this objects fields)\n* Very detailed column meta data:\n    * Allow null\n    * Description\n    * Auto Increment\n    * onUpdate\n    * onDelete\n    * etc. (Full details can be found in callback parameter doc)\n\n## Contributions\n\nAll contributions are welcome. Please send bug reports with tests and small piece of code.\n\n## JSDOC Output\n\n#Index\n\n**Classes**\n\n* [class: Column](#Column)\n  * [new Column(args, [options])](#new_Column)\n  * [column.fullName](#Column#fullName)\n  * [column.name([value])](#Column#name)\n  * [column.defaultWithTypeCast([value])](#Column#defaultWithTypeCast)\n  * [column.default([value])](#Column#default)\n  * [column.allowNull([value])](#Column#allowNull)\n  * [column.type([value])](#Column#type)\n  * [column.special([value])](#Column#special)\n  * [column.enumValues([value])](#Column#enumValues)\n  * [column.length([value])](#Column#length)\n  * [column.precision([value])](#Column#precision)\n  * [column.scale([value])](#Column#scale)\n  * [column.arrayType([value])](#Column#arrayType)\n  * [column.arrayDimension([value])](#Column#arrayDimension)\n  * [column.description([value])](#Column#description)\n  * [column.isAutoIncrement([value])](#Column#isAutoIncrement)\n  * [column.isPrimaryKey([value])](#Column#isPrimaryKey)\n  * [column.isForeignKey([value])](#Column#isForeignKey)\n  * [column.referencesColumn([value])](#Column#referencesColumn)\n  * [column.onUpdate([value])](#Column#onUpdate)\n  * [column.onDelete([value])](#Column#onDelete)\n  * [column.unique([value])](#Column#unique)\n  * [column.table([value])](#Column#table)\n  * [column.parent([value])](#Column#parent)\n  * [column.foreignKeyConstraint([value])](#Column#foreignKeyConstraint)\n  * [column.udType([value])](#Column#udType)\n  * [column.sequelizeType([varName])](#Column#sequelizeType)\n* [class: Constraint](#Constraint)\n  * [new Constraint(args, [options])](#new_Constraint)\n  * [constraint.fullName](#Constraint#fullName)\n  * [constraint.name([value])](#Constraint#name)\n  * [constraint.onUpdate([value])](#Constraint#onUpdate)\n  * [constraint.onDelete([value])](#Constraint#onDelete)\n  * [constraint.table([value])](#Constraint#table)\n  * [constraint.parent([value])](#Constraint#parent)\n  * [constraint.referencesSchema([value])](#Constraint#referencesSchema)\n  * [constraint.referencesTable([value])](#Constraint#referencesTable)\n  * [constraint.through([value])](#Constraint#through)\n  * [constraint.throughForeignKeyConstraint([value])](#Constraint#throughForeignKeyConstraint)\n  * [constraint.throughForeignKeyConstraintToSelf([value])](#Constraint#throughForeignKeyConstraintToSelf)\n  * [constraint.foreignKey(nameOrPos)](#Constraint#foreignKey)\n  * [constraint.foreignKeyExist(nameOrPos)](#Constraint#foreignKeyExist)\n  * [constraint.foreignKeysByName([callback])](#Constraint#foreignKeysByName)\n  * [constraint.foreignKeys([callback])](#Constraint#foreignKeys)\n* [class: DB](#DB)\n  * [new DB(args, [options])](#new_DB)\n  * [dB.fullName](#DB#fullName)\n  * [dB.name([value])](#DB#name)\n  * [dB.addSchema(args)](#DB#addSchema)\n  * [dB.schema(name)](#DB#schema)\n  * [dB.get(path)](#DB#get)\n  * [dB.schemaExist(name)](#DB#schemaExist)\n  * [dB.schemaIncluded(schemaName)](#DB#schemaIncluded)\n  * [dB.includedSchemas()](#DB#includedSchemas)\n  * [dB.schemas([callback])](#DB#schemas)\n* [class: Schema](#Schema)\n  * [new Schema(args, [options])](#new_Schema)\n  * [schema.fullName](#Schema#fullName)\n  * [schema.name([value])](#Schema#name)\n  * [schema.db([value])](#Schema#db)\n  * [schema.parent([value])](#Schema#parent)\n  * [schema.table(name)](#Schema#table)\n  * [schema.get(path)](#Schema#get)\n  * [schema.tables([callback])](#Schema#tables)\n* [class: Table](#Table)\n  * [new Table(args, [options])](#new_Table)\n  * [table.fullName](#Table#fullName)\n  * [table.name([value])](#Table#name)\n  * [table.description([value])](#Table#description)\n  * [table.schema([value])](#Table#schema)\n  * [table.parent([value])](#Table#parent)\n  * [table.column(nameOrPos)](#Table#column)\n  * [table.columns([callback])](#Table#columns)\n  * [table.columnsByName([callback])](#Table#columnsByName)\n  * [table.primaryKeys([callback])](#Table#primaryKeys)\n  * [table.foreignKeyConstraint(name)](#Table#foreignKeyConstraint)\n  * [table.foreignKeyConstraintExist(name)](#Table#foreignKeyConstraintExist)\n  * [table.foreignKeyConstraints([callback])](#Table#foreignKeyConstraints)\n  * [table.foreignKeyConstraintsByName([callback])](#Table#foreignKeyConstraintsByName)\n  * [table.hasMany(name)](#Table#hasMany)\n  * [table.hasManies([callback])](#Table#hasManies)\n  * [table.hasManiesByName([callback])](#Table#hasManiesByName)\n  * [table.hasManyThrough(name)](#Table#hasManyThrough)\n  * [table.hasManyThroughs([callback])](#Table#hasManyThroughs)\n  * [table.hasManyThroughsByName([callback])](#Table#hasManyThroughsByName)\n  * [table.get(path)](#Table#get)\n\n**Members**\n\n* [columnAttributes](#columnAttributes)\n* [constraintAttributes](#constraintAttributes)\n* [schemaAttributes](#schemaAttributes)\n\n**Typedefs**\n\n* [callback: columnCallback](#columnCallback)\n* [callback: schemaCallback](#schemaCallback)\n* [callback: tableCallback](#tableCallback)\n* [callback: columnCallback](#columnCallback)\n* [callback: constraintCallback](#constraintCallback)\n \n<a name=\"Column\"></a>\n#class: Column\n**Members**\n\n* [class: Column](#Column)\n  * [new Column(args, [options])](#new_Column)\n  * [column.fullName](#Column#fullName)\n  * [column.name([value])](#Column#name)\n  * [column.defaultWithTypeCast([value])](#Column#defaultWithTypeCast)\n  * [column.default([value])](#Column#default)\n  * [column.allowNull([value])](#Column#allowNull)\n  * [column.type([value])](#Column#type)\n  * [column.special([value])](#Column#special)\n  * [column.enumValues([value])](#Column#enumValues)\n  * [column.length([value])](#Column#length)\n  * [column.precision([value])](#Column#precision)\n  * [column.scale([value])](#Column#scale)\n  * [column.arrayType([value])](#Column#arrayType)\n  * [column.arrayDimension([value])](#Column#arrayDimension)\n  * [column.description([value])](#Column#description)\n  * [column.isAutoIncrement([value])](#Column#isAutoIncrement)\n  * [column.isPrimaryKey([value])](#Column#isPrimaryKey)\n  * [column.isForeignKey([value])](#Column#isForeignKey)\n  * [column.referencesColumn([value])](#Column#referencesColumn)\n  * [column.onUpdate([value])](#Column#onUpdate)\n  * [column.onDelete([value])](#Column#onDelete)\n  * [column.unique([value])](#Column#unique)\n  * [column.table([value])](#Column#table)\n  * [column.parent([value])](#Column#parent)\n  * [column.foreignKeyConstraint([value])](#Column#foreignKeyConstraint)\n  * [column.udType([value])](#Column#udType)\n  * [column.sequelizeType([varName])](#Column#sequelizeType)\n\n<a name=\"new_Column\"></a>\n##new Column(args, [options])\n**Params**\n\n- args `Object` - Column arguments  \n  - name `string` - Name of the column  \n  - \\[default\\] `string` - Default value of the column  \n  - allowNull `boolean` - Is this column allowed to contain null values?  \n  - type `string` - Data type of the column.  \n  - \\[enumValues\\] `string` - Special attributes of the column.  \n  - \\[length\\] `number` - Length of the column.  \n  - \\[precision\\] `number` - Precision of the column.  \n  - \\[scale\\] `number` - Scale of the column.  \n  - \\[arrayType\\] `string` - If column is array. Data type of the array.  \n  - \\[arrayDimension\\] `number` - array dimension of the column.  \n  - \\[udType\\] `string` - User defined type of the column if the column type is user defined  \n  - \\[description\\] `String` - Description of the table  \n  - table <code>[Table](#Table)</code> - [Table](#Table) of the class  \n- \\[options\\] `Object` - Options  \n  - \\[allowUnknown=true\\] `boolean` - If true, unknown parameters passed to constructor does not throw error while creating object.  \n\n<a name=\"Column#fullName\"></a>\n##column.fullName\nGets full name of the object in database . notation.\n\n<a name=\"Column#name\"></a>\n##column.name([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#defaultWithTypeCast\"></a>\n##column.defaultWithTypeCast([value])\nReturns default value with type cast.\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#default\"></a>\n##column.default([value])\nReturns default value without type cast.\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n**Example**  \nvar column = db('crm').schema('public').table('contact').column('name');\nconsole.log(column.defaultWithTypeCast());  // 'George'::character varying\nconsole.log(column.default());              // George\n\n<a name=\"Column#allowNull\"></a>\n##column.allowNull([value])\n**Params**\n\n- \\[value\\] `boolean` - New value  \n\n**Returns**: `boolean`  \n<a name=\"Column#type\"></a>\n##column.type([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#special\"></a>\n##column.special([value])\nDEPRECATED: use enumValues method instead.\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#enumValues\"></a>\n##column.enumValues([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#length\"></a>\n##column.length([value])\n**Params**\n\n- \\[value\\] `integer` - New value  \n\n**Returns**: `integer`  \n<a name=\"Column#precision\"></a>\n##column.precision([value])\n**Params**\n\n- \\[value\\] `integer` - New value  \n\n**Returns**: `integer`  \n<a name=\"Column#scale\"></a>\n##column.scale([value])\n**Params**\n\n- \\[value\\] `integer` - New value  \n\n**Returns**: `integer`  \n<a name=\"Column#arrayType\"></a>\n##column.arrayType([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#arrayDimension\"></a>\n##column.arrayDimension([value])\n**Params**\n\n- \\[value\\] `integer` - New value  \n\n**Returns**: `integer`  \n<a name=\"Column#description\"></a>\n##column.description([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#isAutoIncrement\"></a>\n##column.isAutoIncrement([value])\n**Params**\n\n- \\[value\\] `boolean` - New value  \n\n**Returns**: `boolean`  \n<a name=\"Column#isPrimaryKey\"></a>\n##column.isPrimaryKey([value])\n**Params**\n\n- \\[value\\] `boolean` - New value  \n\n**Returns**: `boolean`  \n<a name=\"Column#isForeignKey\"></a>\n##column.isForeignKey([value])\n**Params**\n\n- \\[value\\] `boolean` - New value  \n\n**Returns**: `boolean`  \n<a name=\"Column#referencesColumn\"></a>\n##column.referencesColumn([value])\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n<a name=\"Column#onUpdate\"></a>\n##column.onUpdate([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#onDelete\"></a>\n##column.onDelete([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#unique\"></a>\n##column.unique([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#table\"></a>\n##column.table([value])\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n<a name=\"Column#parent\"></a>\n##column.parent([value])\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n<a name=\"Column#foreignKeyConstraint\"></a>\n##column.foreignKeyConstraint([value])\nGets/sets foreign key constraint of the column, if column is a foreign key.\n\n**Params**\n\n- \\[value\\] <code>[Constraint](#Constraint)</code> - New value  \n\n**Returns**: [Constraint](#Constraint)  \n<a name=\"Column#udType\"></a>\n##column.udType([value])\nGets/sets user defined type of the column, if column is a user defined type.\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Column#sequelizeType\"></a>\n##column.sequelizeType([varName])\nReturns Sequelize ORM datatype for column.\n\n**Params**\n\n- \\[varName=DataTypes\\] `String` - Variable name to use in sequelize data type. ie. 'DataTypes' for DataTypes.INTEGER  \n\n**Returns**: `string`  \n**Example**  \nvar typeA = column.sequelizeType();              // DataTypes.INTEGER(3)\nvar typeB = column.sequelizeType('Sequelize');   // Sequelize.INTEGER(3)\n\n<a name=\"Constraint\"></a>\n#class: Constraint\n**Members**\n\n* [class: Constraint](#Constraint)\n  * [new Constraint(args, [options])](#new_Constraint)\n  * [constraint.fullName](#Constraint#fullName)\n  * [constraint.name([value])](#Constraint#name)\n  * [constraint.onUpdate([value])](#Constraint#onUpdate)\n  * [constraint.onDelete([value])](#Constraint#onDelete)\n  * [constraint.table([value])](#Constraint#table)\n  * [constraint.parent([value])](#Constraint#parent)\n  * [constraint.referencesSchema([value])](#Constraint#referencesSchema)\n  * [constraint.referencesTable([value])](#Constraint#referencesTable)\n  * [constraint.through([value])](#Constraint#through)\n  * [constraint.throughForeignKeyConstraint([value])](#Constraint#throughForeignKeyConstraint)\n  * [constraint.throughForeignKeyConstraintToSelf([value])](#Constraint#throughForeignKeyConstraintToSelf)\n  * [constraint.foreignKey(nameOrPos)](#Constraint#foreignKey)\n  * [constraint.foreignKeyExist(nameOrPos)](#Constraint#foreignKeyExist)\n  * [constraint.foreignKeysByName([callback])](#Constraint#foreignKeysByName)\n  * [constraint.foreignKeys([callback])](#Constraint#foreignKeys)\n\n<a name=\"new_Constraint\"></a>\n##new Constraint(args, [options])\n**Params**\n\n- args `Object` - Constraint arguments  \n  - name `string` - Name of the constraint  \n  - referencesSchema <code>[Schema](#Schema)</code> - [Schema](#Schema) containing table which this constraint references to.  \n  - referencesTable <code>[Table](#Table)</code> - [Table](#Table) which this constraint references to.  \n  - \\[onUpdate\\] `string` - Action taken on update. One of: 'NO ACTION', 'CASCADE', 'SET NULL', 'RESTRICT'  \n  - \\[onUpdate\\] `string` - Action taken on delete. One of: 'NO ACTION', 'CASCADE', 'SET NULL', 'RESTRICT'  \n  - table <code>[Table](#Table)</code> - [Table](#Table) object which contains this constraint.  \n  - through <code>[Table](#Table)</code> - [Table](#Table) object which this constraint references through.  \n  - throughForeignKeyConstraint <code>[Table](#Table)</code> - [Constraint](#Constraint) object in through table referencing to other table.  \n  - throughForeignKeyConstraintToSelf <code>[Table](#Table)</code> - [Constraint](#Constraint) object in through table referencing to this table.  \n- \\[options\\] `Object` - Options  \n  - \\[allowUnknown=true\\] `boolean` - If true, unknown parameters passed to constructor does not throw error while creating object.  \n\n<a name=\"Constraint#fullName\"></a>\n##constraint.fullName\nGets full name of the object in database . notation.\n\n<a name=\"Constraint#name\"></a>\n##constraint.name([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Constraint#onUpdate\"></a>\n##constraint.onUpdate([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Constraint#onDelete\"></a>\n##constraint.onDelete([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Constraint#table\"></a>\n##constraint.table([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Constraint#parent\"></a>\n##constraint.parent([value])\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Constraint#referencesSchema\"></a>\n##constraint.referencesSchema([value])\nReturns [Schema](#Schema) object this constraint refers to.\n\n**Params**\n\n- \\[value\\] <code>[Schema](#Schema)</code> - New value  \n\n**Returns**: [Schema](#Schema)  \n<a name=\"Constraint#referencesTable\"></a>\n##constraint.referencesTable([value])\nReturns [Table](#Table) object this constraint refers to.\n\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n<a name=\"Constraint#through\"></a>\n##constraint.through([value])\nReturns [Table](#Table) object this constraint refers through.\n\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n<a name=\"Constraint#throughForeignKeyConstraint\"></a>\n##constraint.throughForeignKeyConstraint([value])\nReturns [Constraint](#Constraint) (foreign key constraint) this constraint referring to other table through join table.\nWith this method it is possible to learn how this table is connected to other table.\n\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n**Example**  \n// Assume there are three tables for many to many relation:  cart ----< line_item >---- product\ndb.get('public.cart').hasManyThrough('cart_has_products').foreignKey(0).name(); // equals 'cart_id'\ndb.get('public.cart').hasManyThrough('cart_has_products').throughForeignKeyConstraint().foreignKey(0).name() // equals 'product_id'\n\n<a name=\"Constraint#throughForeignKeyConstraintToSelf\"></a>\n##constraint.throughForeignKeyConstraintToSelf([value])\nReturns [Constraint](#Constraint) (foreign key constraint) this constraint referring to itself through join table.\nWith this method it is possible to learn how this table is connected to other table.\n\n**Params**\n\n- \\[value\\] <code>[Table](#Table)</code> - New value  \n\n**Returns**: [Table](#Table)  \n<a name=\"Constraint#foreignKey\"></a>\n##constraint.foreignKey(nameOrPos)\nReturns foreign key as a [Column](#Column) object with given name or order number.\n\n**Params**\n\n- nameOrPos `string` | `integer` - Name or order number of the foreign key  \n\n**Returns**: [Column](#Column)  \n<a name=\"Constraint#foreignKeyExist\"></a>\n##constraint.foreignKeyExist(nameOrPos)\nReturns true if foreign key object with given name or order number exists.\n\n**Params**\n\n- nameOrPos `string` | `integer` - Name or order number of the foreign key  \n\n**Returns**: `boolean`  \n<a name=\"Constraint#foreignKeysByName\"></a>\n##constraint.foreignKeysByName([callback])\nRetrieves all foreign keys in the constraint. If callback is provided, it is executed for each foreign key column.\nCallback is passed [Column](#Column) object as parameter. If no callback is provided, returns a plain object. Object keys are column names,\nvalues are [Column](#Column) objects.\n\n**Params**\n\n- \\[callback\\] <code>[columnCallback](#columnCallback)</code> - Callback to be executed for each column.  \n\n**Returns**: `object.<string, Column>` | `undefined`  \n<a name=\"Constraint#foreignKeys\"></a>\n##constraint.foreignKeys([callback])\nRetrieves all foreign keys in the constraint. If callback is provided, it is executed for each foreign key column.\nCallback is passed [Column](#Column) object as parameter. If no callback is provided, returns an array which\ncontains foreign key [Column](#Column) objects.\n\n**Params**\n\n- \\[callback\\] <code>[columnCallback](#columnCallback)</code> - Callback to be executed for each column.  \n\n**Returns**: `object.<string, Column>` | `undefined`  \n<a name=\"DB\"></a>\n#class: DB\n**Members**\n\n* [class: DB](#DB)\n  * [new DB(args, [options])](#new_DB)\n  * [dB.fullName](#DB#fullName)\n  * [dB.name([value])](#DB#name)\n  * [dB.addSchema(args)](#DB#addSchema)\n  * [dB.schema(name)](#DB#schema)\n  * [dB.get(path)](#DB#get)\n  * [dB.schemaExist(name)](#DB#schemaExist)\n  * [dB.schemaIncluded(schemaName)](#DB#schemaIncluded)\n  * [dB.includedSchemas()](#DB#includedSchemas)\n  * [dB.schemas([callback])](#DB#schemas)\n\n<a name=\"new_DB\"></a>\n##new DB(args, [options])\n**Params**\n\n- args `Object` - Database arguments.  \n  - name `String` - Name of the database.  \n- \\[options\\] `Object` - Options  \n  - \\[schemas\\] `array` | `string` - Requested schemas. Information purposes only.  \n  - \\[allowUnknown=true\\] `boolean` - If true, unknown parameters passed to constructor does not throw error while creating object.  \n\n<a name=\"DB#fullName\"></a>\n##dB.fullName\nGets full name of the object in database . notation.\n\n<a name=\"DB#name\"></a>\n##dB.name([value])\nReturns name of the db\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"DB#addSchema\"></a>\n##dB.addSchema(args)\nAdds schema to the schema and returns schema created newly.\n\n**Params**\n\n- args <code>[Schema](#Schema)</code> | `object` - Schema object or general object to create column object  \n  - name `string` - Name of the schema.  \n\n**Returns**: [Schema](#Schema)  \n<a name=\"DB#schema\"></a>\n##dB.schema(name)\nReturns the [Schema](#Schema) object with given name.\n\n**Params**\n\n- name `string` - Name of the schema  \n\n**Returns**: [Schema](#Schema)  \n<a name=\"DB#get\"></a>\n##dB.get(path)\nShortcut function which returns object based on path.\n\n**Params**\n\n- path `string` - Database path of the requested item.  \n\n**Returns**: [Schema](#Schema) | [Table](#Table) | [Column](#Column)  \n**Example**  \nvar schema = db.get('public'),                   // Returns public schema.\n    table  = db.get('public.contact'),           // Returns contact table in public schema.\n    column = db.get('public.contact.name');      // Returns name column of the contact table in public schema.\n\n<a name=\"DB#schemaExist\"></a>\n##dB.schemaExist(name)\nReturns true if object with given name exist.\n\n**Params**\n\n- name `string` - Name of the schema  \n\n**Returns**: `boolean`  \n<a name=\"DB#schemaIncluded\"></a>\n##dB.schemaIncluded(schemaName)\nReturns if given schema is one of the requested schemas to be parsed.\n\n**Params**\n\n- schemaName `string` - Name of the schema to check  \n\n**Returns**: `boolean`  \n<a name=\"DB#includedSchemas\"></a>\n##dB.includedSchemas()\nReturns the list of requested schemas to be parsed.\n\n**Returns**: `Array`  \n<a name=\"DB#schemas\"></a>\n##dB.schemas([callback])\nRetrieves all schemas in the schema. If callback is provided, it is executed for each schema. Callback is passed [Schema](#Schema)\nobject as parameter. If no callback is provided, returns a plain object. Object keys are schema names,\nvalues are [Schema](#Schema) objects.\n\n**Params**\n\n- \\[callback\\] <code>[schemaCallback](#schemaCallback)</code> - Callback to be executed for each schema.  \n\n**Returns**: `object.<string, Schema>` | `undefined`  \n<a name=\"Schema\"></a>\n#class: Schema\n**Members**\n\n* [class: Schema](#Schema)\n  * [new Schema(args, [options])](#new_Schema)\n  * [schema.fullName](#Schema#fullName)\n  * [schema.name([value])](#Schema#name)\n  * [schema.db([value])](#Schema#db)\n  * [schema.parent([value])](#Schema#parent)\n  * [schema.table(name)](#Schema#table)\n  * [schema.get(path)](#Schema#get)\n  * [schema.tables([callback])](#Schema#tables)\n\n<a name=\"new_Schema\"></a>\n##new Schema(args, [options])\n**Params**\n\n- args `Object` - Schema arguments.  \n  - name `string` - Name of the schema.  \n  - db <code>[DB](#DB)</code> - [DB](#DB) of the schema.  \n- \\[options\\] `Object` - Options  \n  - \\[allowUnknown=true\\] `boolean` - If true, unknown parameters passed to constructor does not throw error while creating object.  \n\n<a name=\"Schema#fullName\"></a>\n##schema.fullName\nGets full name of the object in database . notation.\n\n<a name=\"Schema#name\"></a>\n##schema.name([value])\nReturns name of the schema\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Schema#db\"></a>\n##schema.db([value])\nRetrieves [DB](#DB) object of the schema.\n\n**Params**\n\n- \\[value\\] <code>[DB](#DB)</code> - New value  \n\n**Returns**: [DB](#DB)  \n<a name=\"Schema#parent\"></a>\n##schema.parent([value])\nRetrieves [DB](#DB) object of the schema.\n\n**Params**\n\n- \\[value\\] <code>[DB](#DB)</code> - New value  \n\n**Returns**: [DB](#DB)  \n<a name=\"Schema#table\"></a>\n##schema.table(name)\nReturns the [Table](#Table) object with given name.\n\n**Params**\n\n- name `string` - Name of the table  \n\n**Returns**: [Table](#Table)  \n<a name=\"Schema#get\"></a>\n##schema.get(path)\nShortcut function which returns object based on path.\n\n**Params**\n\n- path `string` - Database path of the requested item.  \n\n**Returns**: [Table](#Table) | [Column](#Column)  \n**Example**  \nvar table  = db.get('contact'),           // Returns contact table in public schema.\n    column = db.get('contact.name');      // Returns name column of the contact table in public schema.\n\n<a name=\"Schema#tables\"></a>\n##schema.tables([callback])\nRetrieves all tables in the schema. If callback is provided, it is executed for each table. Callback is passed [Table](#Table)\nobject as parameter. If no callback is provided, returns a plain object. Object keys are table names,\nvalues are [Table](#Table) objects.\n\n**Params**\n\n- \\[callback\\] <code>[tableCallback](#tableCallback)</code> - Callback to be executed for each table.  \n\n**Returns**: `object.<string, Table>` | `undefined`  \n<a name=\"Table\"></a>\n#class: Table\n**Members**\n\n* [class: Table](#Table)\n  * [new Table(args, [options])](#new_Table)\n  * [table.fullName](#Table#fullName)\n  * [table.name([value])](#Table#name)\n  * [table.description([value])](#Table#description)\n  * [table.schema([value])](#Table#schema)\n  * [table.parent([value])](#Table#parent)\n  * [table.column(nameOrPos)](#Table#column)\n  * [table.columns([callback])](#Table#columns)\n  * [table.columnsByName([callback])](#Table#columnsByName)\n  * [table.primaryKeys([callback])](#Table#primaryKeys)\n  * [table.foreignKeyConstraint(name)](#Table#foreignKeyConstraint)\n  * [table.foreignKeyConstraintExist(name)](#Table#foreignKeyConstraintExist)\n  * [table.foreignKeyConstraints([callback])](#Table#foreignKeyConstraints)\n  * [table.foreignKeyConstraintsByName([callback])](#Table#foreignKeyConstraintsByName)\n  * [table.hasMany(name)](#Table#hasMany)\n  * [table.hasManies([callback])](#Table#hasManies)\n  * [table.hasManiesByName([callback])](#Table#hasManiesByName)\n  * [table.hasManyThrough(name)](#Table#hasManyThrough)\n  * [table.hasManyThroughs([callback])](#Table#hasManyThroughs)\n  * [table.hasManyThroughsByName([callback])](#Table#hasManyThroughsByName)\n  * [table.get(path)](#Table#get)\n\n<a name=\"new_Table\"></a>\n##new Table(args, [options])\n**Params**\n\n- args `Object` - Table arguments.  \n  - name `String` - Name of the table.  \n  - \\[description\\] `String` - Description of the table.  \n  - schema <code>[Schema](#Schema)</code> - [Schema](#Schema) of the table.  \n- \\[options\\] `Object` - Options  \n  - \\[allowUnknown=true\\] `boolean` - If true, unknown parameters passed to constructor does not throw error while creating object.  \n\n<a name=\"Table#fullName\"></a>\n##table.fullName\nGets full name of the object in database . notation.\n\n<a name=\"Table#name\"></a>\n##table.name([value])\nRetrieves name of the table.\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Table#description\"></a>\n##table.description([value])\nRetrieves description of the table.\n\n**Params**\n\n- \\[value\\] `string` - New value  \n\n**Returns**: `string`  \n<a name=\"Table#schema\"></a>\n##table.schema([value])\nRetrieves [Schema](#Schema) object of the table.\n\n**Params**\n\n- \\[value\\] <code>[Schema](#Schema)</code> - New value  \n\n**Returns**: [Schema](#Schema)  \n<a name=\"Table#parent\"></a>\n##table.parent([value])\nRetrieves [Schema](#Schema) object of the table.\n\n**Params**\n\n- \\[value\\] <code>[Schema](#Schema)</code> - New value  \n\n**Returns**: [Schema](#Schema)  \n<a name=\"Table#column\"></a>\n##table.column(nameOrPos)\nReturns [Column](#Column) object with given name or order number.\n\n**Params**\n\n- nameOrPos `string` | `integer` - Name or order number of the column  \n\n**Returns**: [Column](#Column)  \n<a name=\"Table#columns\"></a>\n##table.columns([callback])\nRetrieves all columns in the table in an ordered list. If callback is provided, it is executed for each column. Callback is passed [Column](#Column)\nobject as parameter. If no callback is provided, returns array of [Column](#Column) objects.\n\n**Params**\n\n- \\[callback\\] <code>[columnCallback](#columnCallback)</code> - Callback to be executed for each column.  \n\n**Returns**: [Array.&lt;Column&gt;](#Column) | `undefined`  \n<a name=\"Table#columnsByName\"></a>\n##table.columnsByName([callback])\nRetrieves all columns in the table. If callback is provided, it is executed for each column. Callback is passed [Column](#Column)\nobject as parameter. If no callback is provided, returns a plain Object. Object keys are column names,\nvalues are [Column](#Column) objects.\n\n**Params**\n\n- \\[callback\\] <code>[columnCallback](#columnCallback)</code> - Callback to be executed for each column.  \n\n**Returns**: `Object.<string, Column>` | `undefined`  \n<a name=\"Table#primaryKeys\"></a>\n##table.primaryKeys([callback])\nRetrieves all primary key columns in the table. If callback is provided, it is executed for each primary key.\nCallback is passed [Column](#Column) object as parameter.\nIf no callback is provided, returns an array of [Column](#Column) objects.\n\n**Params**\n\n- \\[callback\\] <code>[columnCallback](#columnCallback)</code> - Callback to be executed for each primary key column.  \n\n**Returns**: [Array.&lt;Column&gt;](#Column)  \n<a name=\"Table#foreignKeyConstraint\"></a>\n##table.foreignKeyConstraint(name)\nReturns foreign key [Constraint](#Constraint) object with given name.\n\n**Params**\n\n- name `string` - Name of the foreign key constraint  \n\n**Returns**: [Constraint](#Constraint)  \n<a name=\"Table#foreignKeyConstraintExist\"></a>\n##table.foreignKeyConstraintExist(name)\nReturns true if foreign key object with given name exists.\n\n**Params**\n\n- name `string` - Name of the foreign key constraint  \n\n**Returns**: `boolean`  \n<a name=\"Table#foreignKeyConstraints\"></a>\n##table.foreignKeyConstraints([callback])\nRetrieves all foreign key constraints in the table. If callback is provided, it is executed for each one.\nCallback is passed [Constraint](#Constraint) object as parameter.\nIf no callback is provided, returns a plain Object. Plain object keys are names of [Constraint](#Constraint) objects and values are [Constraint](#Constraint) objects.\n\n**Params**\n\n- \\[callback\\] <code>[constraintCallback](#constraintCallback)</code> - Callback to be executed for each constraint.  \n\n**Returns**: [Array.&lt;Constraint&gt;](#Constraint)  \n<a name=\"Table#foreignKeyConstraintsByName\"></a>\n##table.foreignKeyConstraintsByName([callback])\nRetrieves all foreign key constraints in the table. If callback is provided, it is executed for each one.\nCallback is passed [Constraint](#Constraint) object as parameter.\nIf no callback is provided, returns an array of [Constraint](#Constraint) objects.\n\n**Params**\n\n- \\[callback\\] <code>[constraintCallback](#constraintCallback)</code> - Callback to be executed for each constrained.  \n\n**Returns**: `Object.<string, Constraint>` | `undefined`  \n<a name=\"Table#hasMany\"></a>\n##table.hasMany(name)\nReturns has many [Constraint](#Constraint) object with given name.\n\n**Params**\n\n- name `string` - Name of the has many constraint  \n\n**Returns**: [Constraint](#Constraint)  \n<a name=\"Table#hasManies\"></a>\n##table.hasManies([callback])\nRetrieves all has many constraints in the table. If callback is provided, it is executed for each one.\nCallback is passed [Constraint](#Constraint) object as parameter.\nIf no callback is provided, returns a plain Object. Plain object keys are names of [Constraint](#Constraint) objects and values are [Constraint](#Constraint) objects.\n\n**Params**\n\n- \\[callback\\] <code>[constraintCallback](#constraintCallback)</code> - Callback to be executed for each constraint.  \n\n**Returns**: [Array.&lt;Constraint&gt;](#Constraint)  \n<a name=\"Table#hasManiesByName\"></a>\n##table.hasManiesByName([callback])\nRetrieves all has many constraints in the table. If callback is provided, it is executed for one.\nCallback is passed [Constraint](#Constraint) object as parameter.\nIf no callback is provided, returns an array of [Constraint](#Constraint) objects.\n\n**Params**\n\n- \\[callback\\] <code>[constraintCallback](#constraintCallback)</code> - Callback to be executed for each constraint.  \n\n**Returns**: `Object.<string, Constraint>` | `undefined`  \n<a name=\"Table#hasManyThrough\"></a>\n##table.hasManyThrough(name)\nReturns has many through [Constraint](#Constraint) object with given name.\n\n**Params**\n\n- name `string` - Name of the has many through constraint  \n\n**Returns**: [Constraint](#Constraint)  \n<a name=\"Table#hasManyThroughs\"></a>\n##table.hasManyThroughs([callback])\nRetrieves all has many through constraints in the table. If callback is provided, it is executed for each one.\nCallback is passed [Constraint](#Constraint) object as parameter.\nIf no callback is provided, returns a plain Object. Plain object keys are names of [Constraint](#Constraint) objects and values are [Constraint](#Constraint) objects.\n\n**Params**\n\n- \\[callback\\] <code>[constraintCallback](#constraintCallback)</code> - Callback to be executed for each constraint.  \n\n**Returns**: [Array.&lt;Constraint&gt;](#Constraint)  \n<a name=\"Table#hasManyThroughsByName\"></a>\n##table.hasManyThroughsByName([callback])\nRetrieves all has many through constraints in the table. If callback is provided, it is executed for one.\nCallback is passed [Constraint](#Constraint) object as parameter.\nIf no callback is provided, returns an array of [Constraint](#Constraint) objects.\n\n**Params**\n\n- \\[callback\\] <code>[constraintCallback](#constraintCallback)</code> - Callback to be executed for each constraint.  \n\n**Returns**: `Object.<string, Constraint>` | `undefined`  \n<a name=\"Table#get\"></a>\n##table.get(path)\nShortcut function which returns object based on path.\n\n**Params**\n\n- path `string` - Database path of the requested item.  \n\n**Returns**: [Column](#Column)  \n**Example**  \nvar column = db.get('name');      // Returns name column of the contact table in public schema.\n\n<a name=\"columnAttributes\"></a>\n#columnAttributes\nAllowed column attributes and validations.\n\n**Type**: `Object`  \n<a name=\"constraintAttributes\"></a>\n#constraintAttributes\nAllowed column attributes and validations.\n\n**Type**: `Object`  \n<a name=\"schemaAttributes\"></a>\n#schemaAttributes\nAllowed schema attributes and validations.\n\n**Type**: `Object`  \n<a name=\"columnCallback\"></a>\n#callback: columnCallback\n**Params**\n\n- column <code>[Column](#Column)</code> - Column object  \n\n**Type**: `function`  \n<a name=\"schemaCallback\"></a>\n#callback: schemaCallback\n**Params**\n\n- schema <code>[Schema](#Schema)</code> - Schema object  \n\n**Type**: `function`  \n<a name=\"tableCallback\"></a>\n#callback: tableCallback\n**Params**\n\n- table <code>[Table](#Table)</code> - Table object  \n\n**Type**: `function`  \n<a name=\"columnCallback\"></a>\n#callback: columnCallback\n**Params**\n\n- column <code>[Column](#Column)</code> - Column object  \n\n**Type**: `function`  \n<a name=\"constraintCallback\"></a>\n#callback: constraintCallback\n**Params**\n\n- constraint <code>[Constraint](#Constraint)</code> - Constraint object  \n\n**Type**: `function`  \n\n---------------------------------------\n\n<a name=\"History\"></a>\nHistory & Release Notes\n=======================\n\nNote\n----\nVersion history for minimal documentation updates are not listed here to prevent cluttering.\nImportant documentation changes are included anyway.\n\n1.11.0 / 2014-12-30\n===================\n* Added: Constraint.throughForeignKeyConstraintToSelf() method added.\n* Added: Winston logging.\n* Fixed: Many to Many relations has name collisions if join table connects more than one table and one of the tables has more than one connection to join table. Naming of many to many relations changed.\n\n1.10.0 / 2014-12-23\n==================\n* Added: db.includedSchemas method to get list of requested schemas to be parsed.\n* Added: db.schemaIncluded method to determine if given schema name is one of the requested schemas to be parsed.\n* Fix: If a table has a reference to not included schema, throws exception. Should not include its foreign key.\n* Doc update.\n\n1.9.0 / 2014-12-12\n==================\n* Added: table.hasManyThrough.throughForeignKeyConstraint method added to constraint class.\n\n1.8.3 / 2014-12-10\n==================\n* Fix: Sequelize type length, precision.\n\n1.8.2 / 2014-12-10\n==================\n* Fix: Sequelize type date, time etc. has no length property.\n* Fix: Sequelize type dateonly added.\n* Tests added.\n\n1.8.0 / 2014-12-10\n==================\n* Added: Shortcut function 'get' added to db, schema and table classes.\n* Fix: hasManyThrough does not return foreign keys.\n\n1.7.0 / 2014-12-10\n==================\n* Added: onDelete and onUpdate added to hasMany and hasManyThrough relations.\n\n1.6.0 / 2014-12-10\n==================\n* DEPRECATED: column.special function. Use column.enumValues instead.\n* Added: Tests for enum values.\n* Added: Enum support for column.sequelizeType function.\n* Updated: Documentation\n\n1.5.1 / 2014-12-04\n==================\n* Fix: Test db does not destroyed after tests.\n\n1.5.0 / 2014-12-04\n==================\n* Fix: column.default() method returns default value with type cast. From now on yype cast part is stripped.\n* Added column.defaultWithTypeCast() method for getting default values with type cast part.\n* Tests added for default values.\n\n1.4.0 / 2014-11-28\n==================\n* Added support for user-defined types.\n* Added column.udType() method to get user defined type name.\n* Added necessary tests.\n\n1.3.1 / 2014-11-27\n==================\n* Added history to readme.\n* Fix: Major error: Single schema or default 'public' schema databases throw error.\n* Fix: Databases without any table throw error.\n* Added tests of this fixes and table without any column.\n\n\n1.3.0 / 2014-11-27\n==================\n* Parameter validation added to pg-structure main function. This would ease debugging.\n* Fix: pg-structure.generate function was throwing error, now it calls its callback with error\nif database connection error occurs.\n\n1.2.1 / 2014-11-26\n==================\n* Fix: Documentation updated for 1.2\n\n1.2.0 / 2014-11-26\n==================\n* Fix: pg-structure callback does not get error object. Instead error is thrown. Now callback gets error object as its first parameter as expected.\n* db.schema() function now throws more informative error if referenced schema is not found in db and also not in the options of requested schemas.\n* db.schemaExist() function added.\n* History.md file added. (This file)\n\n1.1.0 / 2014-11-25\n==================\n* table.foreignKeyConstraintExist() function added.\n\n1.0.0 / 2014-11-25\n==================\n* Completely rewritten to migrate from plain object to object oriented design.\n* column.sequelizeType() method added. This method gets sequelize compatible type of the column.\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Ozum Eldogan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n",
  "readmeFilename": "README.md",
  "gitHead": "4c8e57fc50de4b193dc7dedf21c7062bb1d46041",
  "bugs": {
    "url": "https://github.com/ozum/pg-structure/issues"
  },
  "homepage": "https://github.com/ozum/pg-structure",
  "_id": "pg-structure@1.11.1",
  "_shasum": "bca18e1416ecbc8349806eb18c479930678ceb24",
  "_from": "pg-structure@1.11.1"
}
